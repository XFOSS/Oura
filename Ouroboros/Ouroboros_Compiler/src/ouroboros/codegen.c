// codegen.c
// This file will contain the code generation logic for the Ouroboros compiler.
// It will take the Abstract Syntax Tree (AST) as input and produce
// executable code (e.g., bytecode, assembly, or C for a C backend).

#include "../include/codegen.h"
#include "../include/ast.h"
#include "../include/token.h"
#include "../include/common.h" // For error reporting, common utilities
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// --- Internal Helper Function Declarations ---
// (These will be populated as codegen develops)
static void generate_code_for_node(CodeGenerator* codegen, ASTNode* node);
static void generate_code_for_program(CodeGenerator* codegen, ProgramNode* program_node);
static void generate_code_for_expression(CodeGenerator* codegen, ExpressionNode* expr_node);
// ... more specific generation functions for different AST node types ...


// --- Public API Implementations ---

/**
 * Initializes a new CodeGenerator instance.
 * @param output_file The FILE pointer to write generated code to.
 * @return A dynamically allocated CodeGenerator pointer.
 */
CodeGenerator* codegen_init(FILE* output_file) {
    CodeGenerator* codegen = (CodeGenerator*)ouro_malloc(sizeof(CodeGenerator));
    codegen->output_file = output_file;
    // Initialize any internal state, symbol tables, register allocators etc.
    // For now, it's minimal.
    return codegen;
}

/**
 * Generates code from the given Abstract Syntax Tree.
 * This is the main entry point for the code generation phase.
 * @param codegen A pointer to the CodeGenerator instance.
 * @param ast_root The root of the AST (a ProgramNode).
 * @return True if code generation was successful, false otherwise.
 */
bool codegen_generate(CodeGenerator* codegen, ASTNode* ast_root) {
    if (codegen == NULL || ast_root == NULL) {
        fprintf(stderr, "Code generation error: Invalid CodeGenerator or AST root.\n");
        return false;
    }
    if (ast_root->base_type != NODE_PROGRAM) {
        fprintf(stderr, "Code generation error: AST root is not a ProgramNode.\n");
        return false;
    }

    printf("--- Starting Code Generation ---\n");
    // This is a placeholder. Real code generation would traverse the AST
    // and emit target-specific instructions.
    fprintf(codegen->output_file, "// Generated by %s Compiler (v%s)\n",
            OUROBOROS_COMPILER_NAME, OUROBOROS_COMPILER_VERSION);
    fprintf(codegen->output_file, "// Source AST Node Type: %s\n\n",
            ast_node_type_to_string(ast_root->base_type));

    generate_code_for_program(codegen, (ProgramNode*)ast_root);

    printf("--- Code Generation Complete ---\n");
    return true;
}

/**
 * Frees the memory associated with a CodeGenerator instance.
 * Does NOT close the output_file.
 * @param codegen A pointer to the CodeGenerator instance to free.
 */
void codegen_free(CodeGenerator* codegen) {
    if (codegen) {
        // Clean up any internal data structures used by the code generator
        free(codegen);
    }
}


// --- Internal Helper Function Implementations ---

static void generate_code_for_node(CodeGenerator* codegen, ASTNode* node) {
    if (node == NULL) return;

    // This switch will grow significantly as more AST node types are added.
    switch (node->base_type) {
        case NODE_PROGRAM:
            generate_code_for_program(codegen, (ProgramNode*)node);
            break;
        case NODE_EXPRESSION:
            generate_code_for_expression(codegen, (ExpressionNode*)node);
            break;
        // Placeholder for other nodes
        case NODE_PACKAGE_DECLARATION:
            fprintf(codegen->output_file, "// Package Declaration: %s\n", ((PackageDeclarationNode*)node)->package_name->name);
            break;
        case NODE_IMPORT_DECLARATION:
            fprintf(codegen->output_file, "// Import Declaration: %s%s\n",
                    ((ImportDeclarationNode*)node)->imported_name->name,
                    ((ImportDeclarationNode*)node)->is_wildcard ? ".*" : "");
            break;
        case NODE_CLASS_INTERFACE_DECLARATION:
            fprintf(codegen->output_file, "// Class Declaration: %s\n", ((ClassInterfaceDeclarationNode*)node)->name->name);
            // Recursively generate code for class members
            for (size_t i = 0; i < ((ClassInterfaceDeclarationNode*)node)->member_count; ++i) {
                generate_code_for_node(codegen, ((ClassInterfaceDeclarationNode*)node)->members[i]);
            }
            break;
        case NODE_FUNCTION_DECLARATION:
            fprintf(codegen->output_file, "// Function Declaration: %s\n", ((FunctionDeclarationNode*)node)->name->name);
            // Generate code for function body (if any)
            if (((FunctionDeclarationNode*)node)->body) {
                generate_code_for_node(codegen, (ASTNode*)((FunctionDeclarationNode*)node)->body);
            }
            break;
        case NODE_FIELD_DECLARATION:
            fprintf(codegen->output_file, "// Field Declaration: %s %s\n",
                    ((FieldDeclarationNode*)node)->type->name,
                    ((FieldDeclarationNode*)node)->name->name);
            if (((FieldDeclarationNode*)node)->initializer) {
                fprintf(codegen->output_file, "// Field Initializer:\n");
                generate_code_for_expression(codegen, ((FieldDeclarationNode*)node)->initializer);
            }
            break;
        case NODE_CONSTRUCTOR_DECLARATION:
             fprintf(codegen->output_file, "// Constructor Declaration for: %s\n", ((ConstructorDeclarationNode*)node)->class_name->name);
             if (((ConstructorDeclarationNode*)node)->body) {
                generate_code_for_node(codegen, (ASTNode*)((ConstructorDeclarationNode*)node)->body);
            }
            break;
        case NODE_ENUM_DECLARATION:
             fprintf(codegen->output_file, "// Enum Declaration: %s\n", ((EnumDeclarationNode*)node)->name->name);
             // TODO: Generate code for enum members
            break;
        case NODE_STATEMENT:
            // Statements need individual handling based on their specific type
            if (node->statement_type == STMT_BLOCK) {
                BlockStatementNode* block = (BlockStatementNode*)node;
                fprintf(codegen->output_file, "{\n"); // Simple brace for C-like output
                for (size_t i = 0; i < block->statement_count; ++i) {
                    generate_code_for_node(codegen, (ASTNode*)block->statements[i]);
                }
                fprintf(codegen->output_file, "}\n");
            } else if (node->statement_type == STMT_EXPRESSION) {
                ExpressionStatementNode* expr_stmt = (ExpressionStatementNode*)node;
                generate_code_for_expression(codegen, expr_stmt->expression);
                fprintf(codegen->output_file, ";\n");
            }
            // Add more statement types here as they are parsed
            break;
        case NODE_TYPE_REFERENCE:
        case NODE_IDENTIFIER:
        case NODE_PARAMETER:
            // These might not generate code directly but are part of other nodes.
            // For now, just a comment.
            fprintf(codegen->output_file, "// Encountered AST Node: %s\n", ast_node_type_to_string(node->base_type));
            break;
        default:
            fprintf(codegen->output_file, "// WARNING: Unknown AST Node Type encountered: %s\n", ast_node_type_to_string(node->base_type));
            break;
    }
}


static void generate_code_for_program(CodeGenerator* codegen, ProgramNode* program_node) {
    if (program_node == NULL) return;

    for (size_t i = 0; i < program_node->declaration_count; ++i) {
        generate_code_for_node(codegen, program_node->declarations[i]);
        fprintf(codegen->output_file, "\n"); // Separate top-level declarations
    }
}

static void generate_code_for_expression(CodeGenerator* codegen, ExpressionNode* expr_node) {
    if (expr_node == NULL) return;

    switch (expr_node->expr_type) {
        case EXPR_LITERAL: {
            LiteralNode* literal = (LiteralNode*)expr_node;
            switch (literal->value_type) {
                case BOOLEAN_LITERAL:
                    fprintf(codegen->output_file, "%s", literal->value.boolean_val ? "true" : "false");
                    break;
                case INTEGER_LITERAL:
                    fprintf(codegen->output_file, "%lld", literal->value.integer_val);
                    break;
                case FLOATING_POINT_LITERAL:
                    fprintf(codegen->output_file, "%f", literal->value.float_val);
                    break;
                case STRING_LITERAL:
                    // Simple string literal, needs proper escaping for C output
                    fprintf(codegen->output_file, "\"%s\"", literal->value.string_val);
                    break;
                case CHARACTER_LITERAL:
                    fprintf(codegen->output_file, "'%c'", literal->value.char_val);
                    break;
                case NULL_LITERAL:
                    fprintf(codegen->output_file, "null");
                    break;
                default:
                    fprintf(codegen->output_file, "/* UNKNOWN_LITERAL_TYPE */");
                    break;
            }
            break;
        }
        case EXPR_IDENTIFIER: {
            IdentifierNode* id = (IdentifierNode*)expr_node;
            fprintf(codegen->output_file, "%s", id->name);
            break;
        }
        case EXPR_UNARY: {
            UnaryExpressionNode* unary = (UnaryExpressionNode*)expr_node;
            // Determine if prefix or postfix (based on token type and context in a real impl)
            // For now, assume prefix if it's a typical unary op, postfix for increment/decrement
            if (unary->operator->type == INCREMENT || unary->operator->type == DECREMENT) {
                generate_code_for_expression(codegen, (ExpressionNode*)unary->operand);
                fprintf(codegen->output_file, "%s", unary->operator->lexeme);
            } else {
                fprintf(codegen->output_file, "%s", unary->operator->lexeme);
                generate_code_for_expression(codegen, (ExpressionNode*)unary->operand);
            }
            break;
        }
        case EXPR_BINARY: {
            BinaryExpressionNode* binary = (BinaryExpressionNode*)expr_node;
            fprintf(codegen->output_file, "("); // Add parentheses for correct precedence
            generate_code_for_expression(codegen, (ExpressionNode*)binary->left);
            fprintf(codegen->output_file, " %s ", binary->operator->lexeme);
            generate_code_for_expression(codegen, (ExpressionNode*)binary->right);
            fprintf(codegen->output_file, ")");
            break;
        }
        case EXPR_ASSIGNMENT: {
            AssignmentExpressionNode* assign = (AssignmentExpressionNode*)expr_node;
            generate_code_for_expression(codegen, (ExpressionNode*)assign->target);
            fprintf(codegen->output_file, " %s ", assign->operator->lexeme);
            generate_code_for_expression(codegen, (ExpressionNode*)assign->value);
            break;
        }
        case EXPR_CALL: {
            CallExpressionNode* call = (CallExpressionNode*)expr_node;
            generate_code_for_expression(codegen, (ExpressionNode*)call->callee);
            fprintf(codegen->output_file, "(");
            for (size_t i = 0; i < call->argument_count; ++i) {
                generate_code_for_expression(codegen, (ExpressionNode*)call->arguments[i]);
                if (i < call->argument_count - 1) {
                    fprintf(codegen->output_file, ", ");
                }
            }
            fprintf(codegen->output_file, ")");
            break;
        }
        case EXPR_MEMBER_ACCESS: {
            MemberAccessExpressionNode* member = (MemberAccessExpressionNode*)expr_node;
            generate_code_for_expression(codegen, (ExpressionNode*)member->object);
            fprintf(codegen->output_file, ".%s", member->member_name->name);
            break;
        }
        case EXPR_ARRAY_ACCESS: {
            ArrayAccessExpressionNode* array_access = (ArrayAccessExpressionNode*)expr_node;
            generate_code_for_expression(codegen, (ExpressionNode*)array_access->array);
            fprintf(codegen->output_file, "[");
            generate_code_for_expression(codegen, (ExpressionNode*)array_access->index);
            fprintf(codegen->output_file, "]");
            break;
        }
        case EXPR_TERNARY: {
            TernaryExpressionNode* ternary = (TernaryExpressionNode*)expr_node;
            fprintf(codegen->output_file, "(");
            generate_code_for_expression(codegen, (ExpressionNode*)ternary->condition);
            fprintf(codegen->output_file, " ? ");
            generate_code_for_expression(codegen, (ExpressionNode*)ternary->true_expr);
            fprintf(codegen->output_file, " : ");
            generate_code_for_expression(codegen, (ExpressionNode*)ternary->false_expr);
            fprintf(codegen->output_file, ")");
            break;
        }
        // Add more expression types here
        default:
            fprintf(codegen->output_file, "/* UNKNOWN_EXPRESSION_TYPE (%s) */", ast_node_type_to_string(expr_node->base.base_type));
            break;
    }
}